##########################
# Autor: Junyeob Baek
# email: wnsdlqjtm@gmail.com
##########################

from anytree import Node, RenderTree
from random import sample
import numpy as np
import matplotlib.pyplot as plt
from shapely.geometry import Polygon, Point


def is_feasible(obstacles, x):
    p = Point(x[0], x[1])

    for obs in obstacles:
        if obs.contains(p):
            return False

    return True


def is_goal(goal_pos, new_node):
    dist = np.linalg.norm(np.array(goal_pos) - np.array(new_node.data))
    return True if dist < 0.05 else False


def render(problem, tree, x_tree, x_rand):
    init_pos, goal_pos, x_lim, y_lim, obstacles = problem

    # plot init and goal
    plt.scatter(init_pos[0], init_pos[1], c="k", label="init")
    plt.scatter(goal_pos[0], goal_pos[1], c="r", label="goal")

    # plot x_tree and x_rand
    plt.scatter(x_tree[0], x_tree[1], c="k", marker="^", label="x_tree")
    plt.scatter(x_rand[0], x_rand[1], c="r", marker="^", label="x_rand")

    # render all tree nodes
    for row in RenderTree(tree):
        pre, fill, node = row
        leaf_x = [n.data[0] for n in node.children]
        leaf_y = [n.data[1] for n in node.children]
        plt.scatter(leaf_x, leaf_y, s=1, c="b")

    for obs in obstacles:
        xs, ys = obs.exterior.xy
        plt.fill(xs, ys, fc="m", label="obstacle")

    # save figure
    plt.title("Tree-Growth Sampling Search")
    plt.legend()
    plt.xlim(x_lim[0], x_lim[1])
    plt.ylim(y_lim[0], y_lim[1])
    plt.savefig(f"{len(all_nodes)}.png")
    plt.cla()


if __name__ == "__main__":
    # Problem Setup
    all_nodes = []
    num_max_tries = 5
    stepscale = 0.5
    is_achieved = False

    # set init and goal
    init_pos = [-4, -1]
    goal_pos = [4, 7]

    # set the boundary of configuration space
    x_lim = [-10, 10]
    y_lim = [-10, 10]

    # obstacles
    obstacles = [
        Polygon([(-1, 4), (-2, 3), (1, 1), (4, 1)]),
    ]

    # set problem
    problem = (init_pos, goal_pos, x_lim, y_lim, obstacles)

    # initialize a tree with an initial configuration
    root = Node("root", data=init_pos)
    all_nodes.append(root)

    cnt = 0
    while not is_achieved:
        # select a random node from tree
        x_tree = sample(all_nodes, 1)[0]

        # select random configuration from the collision-free configuration space
        x_rand = None
        scnt = 0
        while x_rand is None:
            sampled_x = [
                np.random.uniform(low=x_lim[0], high=x_lim[1]),
                np.random.uniform(low=y_lim[0], high=y_lim[1]),
            ]

            if is_feasible(obstacles, sampled_x):
                x_rand = sampled_x

            if scnt > num_max_tries:
                raise Exception("Exceeded the maximum number of attempts")

        # extend from x_tree to x_rand
        dist = np.linalg.norm(np.array(x_tree.data) - np.array(x_rand))
        extended_nodes = zip(
            np.arange(
                x_tree.data[0], x_rand[0], stepscale/dist * (x_rand[0] - x_tree.data[0])
            ),
            np.arange(
                x_tree.data[1], x_rand[1], stepscale/dist * (x_rand[1] - x_tree.data[1])
            ),
        )
        # TODO: drawing error in some cases

        # add the new nodes to the tree
        x_before = None
        for x_ext in extended_nodes:
            if is_feasible(obstacles, x_ext):
                new_node = Node(
                    f"{len(all_nodes)}",
                    parent=x_tree if x_before != None else x_before,
                    data=x_ext,
                )
                all_nodes.append(new_node)

                # if goal configuration is added to the tree, terminate
                if is_goal(goal_pos, new_node):
                    is_achieved = True
                    break

                x_before = new_node
            else:
                break

        # plot scene and tree nodes
        render(problem, root, x_tree.data, x_rand)

# TODO: draw resulting found path
